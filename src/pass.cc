#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include <unistd.h>
#include <limits.h>
#include "util.h"
#include "sorter.h"
#include "fastareader.h"
#include "seqreader.h"
#define MIN_SORTSIZE 1073741824
#define MIN_SHORTSEQ_LEN 4
void help_main() {
	fprintf(stderr, 
"Try\n\
        'pass --version for version information.\n\
        'pass indexref --help', 'pass indexqry --help', 'pass align --help' for\n\
           detailed usage information.\n\
\n\
EXAMPLES\n\
        pass indexref -l 32 -o reference.pass reference.fasta\n\
        pass indexqry -u 1 -o query.pass query.fasta\n\
        pass align -n unlimited -f 1 -t 1 query.pass reference.pass > align.txt\n\
\n\
        The first command generates an index file for reference fasta file\n\
          'reference.fasta'. The index allows alignment for query sequences of\n\
          length less than or equal to 32.\n\
\n\
        The second command generates an index file for query fasta file\n\
          'query.fasta'. The index file allows up to 1 mismatch.\n\
\n\
        The third command aligns the above two sequences without any\n\
          limitation on match number.\n");
	exit(1);
}
void help_align() {
	fprintf(stderr, 
"Usage: pass align [OPTION]... REFINDEX QRYINDEX\n\
Align query sequence to reference sequence where REFINDEX is reference\n\
  sequence's index file, and where QRYINDEX is query sequence's index file. The\n\
  two files are generated by 'pass indexref' and 'pass indexqry'.\n\
\n\
Basic arguments\n\
  -n, --max-num-of-match=N\n\
        N can be\n\
        'unlimited'\n\
                All mathces in the mismatch level will be printed.\n\
        An integer between 0 and 254\n\
                Query sequences that have more than N matches are filtered out.\n\
                Please note: The bigger number N is, the more memory is used.\n\
        (default 1)\n\
  -f, --from-mismatch=FROMMISMATCH\n\
        do FROMMISMATCH-mismatch alignment first, filter out sequence that has\n\
	match, then do (NUM+1), until TOMISMATH\n\
        (default: 0)\n\
  -t, --to-mismatch=TOMISMATCH\n\
        Allow TOMISMATCH mismatches.\n\
        (default: the specified mismatch number when indexing query sequences)\n\
Advanced arguments\n\
  -g, --gap-of-indel=LENGTH\n\
        Allow indel length of up to LENGTH.\n\
  -q, --quality-score-base=BASE\n\
        Use quality score if possible, BASE can be\n\
        An integer between 0 and 255\n\
                output quality score is (original score - BASE).\n\
                set BASE to 33 for normal fastq file, 64 for solexa fastq file.\n\
        'solexa'\n\
                BASE is set to 64.\n\
        'normal'\n\
                BASE is set to 33.\n\
        'none'\n\
                quality score is not used.\n\
        (default: 'none')\n\
  -s, --sequence\n\
        Print sequence, as well as its ID.\n\
  -p, --print-all\n\
        Print 'NM' for sequence IDs that have no match.\n\
        Print 'FT' for sequence IDs that are filtered due to too many matches.\n\
      --help\n\
        Display this help and exit\n\
      --version\n\
        Output version information and exit\n");
	exit(1);
}
void help_indexref() {
	fprintf(stderr, 
"Usage: pass indexref [OPTION]... FASTA\n\
create index file for reference sequence fasta file FASTA\n\
\n\
Basic arguments\n\
  -o, --output=OUT\n\
        Name of the index file\n\
  -l, --max-length=LENGTH\n\
        Maximum length possible for query sequences\n\
        (default 50)\n\
Advanced arguments\n\
  -f, --id-from=STRING\n\
        Remove STRING and any leading characters from the start of the sequence\n\
          ID\n\
        (default \"\")\n\
  -t, --id-to=STRING\n\
        Remove STRING and any trailing characters from the end of the sequence\n\
          ID\n\
        (default \"\")\n\
  -s, --max-memory-size=MSIZE(kK|mM|gG)\n\
        Soft limit for maximum memory usage.\n\
        (default 2G)\n\
  -b, --bisulfite-conversion\n\
        Bisulfite-conversion alignment. A pair comprising a query sequence T\n\
          and a reference sequence C is considered a match.\n\
      --help\n\
        Display this help and exit\n\
      --version\n\
        Output version information and exit\n");
	exit(1);
}
void help_indexqry() {
	fprintf(stderr, 
"Usage: pass indexqry [OPTION]... FASTA\n\
create index file for query sequence fasta file FASTA\n\
\n\
Basic arguments\n\
  -o, --output=OUT\n\
        Name of the index file\n\
  -u, --up-to-mismatch=NUM\n\
        Allow up to NUM mismatches per alignment. (default 2)\n\
Advanced arguments\n\
  -f, --id-from=STRING\n\
        Remove STRING and any leading characters from the start of the sequence\n\
          ID\n\
        (default \"\")\n\
  -t, --id-to=STRING\n\
        Remove STRING and any trailing characters from the end of the sequence\n\
          ID\n\
        (default \"\")\n\
  -s, --max-memory-size=MSIZE(kK|mM|gG)\n\
        Soft limit for maximum memory usage. 0 means limit is determined by\n\
          fasta input file size.\n\
        A good starting point is half of the physical memory on an unloaded\n\
          system.\n\
        Bigger is better but do not exceed the physical memory!!\n\
        (default 0)\n\
  -b, --bisulfite-conversion\n\
        Bisulfite-conversion alignment. A pair comprising a query sequence T\n\
          and a reference sequence C is considered a match.\n\
      --help\n\
        Display this help and exit\n\
      --version\n\
        Output version information and exit\n");
	exit(1);
}
void version() {
	fprintf(stderr, "%s, Presorted Alignment for Short Sequences\n\
\n\
Copyright 2002-2024, MNI, University of Michigan.\n\
The MIT License <https://opensource.org/license/mit/>.\n\
Written by Manhong Dai.\n\
There is NO WARRANTY, to the extent permitted by law.\n", PACKAGE_STRING);
	exit(1);
}
int64_t str2long(char *s, int64_t lower, int64_t upper) {
	char *tail;
	int64_t rtn = strtol(s, &tail, 10);
	if (*tail)
		utl_error("main", 1,
			"Integer type parameter is needed, try 'pass --help' for more information\n");
	if (rtn < lower || rtn > upper)
		utl_error("main", 2,
			"Integer parameter is not in acceptable range, try 'pass --help' for more information\n");
	return rtn;
}
void pass_indexref(int argc, char *argv[]) {
	char *id_from = NULL, *id_to = NULL, *output = NULL;
	uint64_t max_mem = 2147483648LLU;
	uint64_t max_len = 50;
	bool bisulfite = false;
	while (1) {
		int option_index = 0;
		static struct option l_options[] = {
			{"help", 0, 0, 0},
			{"version", 0, 0, 0},
			{"id-from", 1, 0, 'f'},
			{"id-to", 1, 0, 't'},
			{"output", 1, 0, 'o'},
			{"max-memory-size", 1, 0, 's'},
			{"bisulfite-conversion", 0, 0, 'b'},
			{"max-length", 1, 0, 'l'},
			{0, 0, 0, 0}
		};
		int opt = getopt_long(argc, argv, "f:t:o:s:bl:", l_options, &option_index);
		if (opt == -1) break;
		switch(opt) {
			case 0:
				switch (option_index) {
					case 0:
						help_indexref();
					case 1:
						version();
				}
				exit(-1);
			case 'f':
				id_from = optarg;
				break;
			case 't':
				id_to = optarg;
				break;
			case 'o':
				output = optarg;
				break;
			case 's':
				char *tail;
				max_mem = strtol(optarg, &tail, 10);
				if (*tail == 'K' || *tail == 'k') 
					max_mem *= 1024;
				else if (*tail == 'M' || *tail == 'm') 
					max_mem *= 1048576;
				else if (*tail == 'G' || *tail == 'g') 
					max_mem *= 1073741824;
				else if (*tail && *tail != 'B' && *tail != 'b') 
					help_indexref();
				break;
			case 'b':
				bisulfite = true;
				break;
			case 'l':
				max_len = str2long(optarg, 4, 1023);
				break;
			default:
				exit(1);
		}
	}
	if (optind+1 != argc)
		utl_error("main", 3,
			"pass indexref: missing mandatory operand 'fasta file name'\npass indexref: Try 'pass indexref --help' for more information.\n");
	if (!output)
		utl_error("main", 4,
			"pass indexref: missing mandatory operand '--output'\npass indexref: Try 'pass indexref --help' for more information.\n");
	FILE *fout = fopen(output, "w");
	if (fout == NULL) utl_error("main", 5, "pass indexref: Cannot create file '%s'\n", output);
	char *sMajor = strdup(PACKAGE_VERSION); 
	char *sPeriod = strrchr(sMajor, '.');
	if (!sPeriod)
		utl_error("main", 6,
			"pass indexref: package version string is wrong, contact developer");
	*sPeriod = 0;
	unsigned char major_len = (unsigned char) strlen(sMajor);
	check_write(fwrite(&major_len, sizeof(unsigned char), 1, fout) == 1);
	check_write(fwrite(sMajor, major_len, 1, fout) == 1);
	free(sMajor);
	check_write(fwrite(&bisulfite, sizeof(bool), 1, fout) == 1);
	check_write(fputc('R', fout) != EOF);
	check_write(fwrite(&max_len, sizeof(uint64_t), 1, fout) == 1);
	fasta_reader *fa_reader = new fasta_reader(argv[optind], true, id_from, id_to, fout);
	if (max_mem > fa_reader->get_size()) max_mem -= fa_reader->get_size();
	if (max_mem < MIN_SORTSIZE)max_mem = MIN_SORTSIZE;
	char* tmpfile = (char*)malloc(strlen(output) + 9);
	check_alloc(tmpfile);
	sprintf(tmpfile, "%s.tmpfile", output);

	char *seq = fa_reader->get_seq_buffer();
	sorter* srtr = new sorter(seq, fout, tmpfile, max_mem, bisulfite, 131072);
	uint64_t head = 0;
	unsigned int seq_idx = 0;
	bool appended = false;
	while (seq[head] != -1) {
		uint64_t tail = head;
		while (seq[tail] && seq[tail] != 'N')
			tail++;
		if (head + MIN_SHORTSEQ_LEN <= tail) appended = true;
		for (uint64_t i = head+max_len; i <= tail; i++, head++)
			srtr->append(sequence(head, max_len, seq_idx));
		for (; head+MIN_SHORTSEQ_LEN <= tail; head++)
			srtr->append(sequence(head, tail - head, seq_idx));
		head = tail + 1;
		if (!seq[tail]) seq_idx++;
	}
	delete srtr;
	free(tmpfile);
	fclose(fout);
	delete fa_reader;
	if (!appended) {
		unlink(output);
		utl_error("main", 7, "Reference fasta file '%s' has no sequence.\n", output);
	}
}
void pass_indexqry(int argc, char *argv[]) {
	char *id_from = NULL, *id_to = NULL, *output = NULL;
	uint64_t max_mem = 2147483648LLU;
	unsigned char mis_thr = 2;
	bool bisulfite = false;
	while (1) {
		int option_index = 0;
		static struct option l_options[] = {
			{"help", 0, 0, 0},
			{"version", 0, 0, 0},
			{"id-from", 1, 0, 'f'},
			{"id-to", 1, 0, 't'},
			{"output", 1, 0, 'o'},
			{"max-memory-size", 1, 0, 's'},
			{"bisulfite-conversion", 0, 0, 'b'},
			{"up-to-mismatch", 1, 0, 'u'},
			{0, 0, 0, 0}
		};
		int opt = getopt_long(argc, argv, "f:t:o:s:bu:", l_options, &option_index);
		if (opt == -1) break;
		switch(opt) {
			case 0:
				switch (option_index) {
					case 0:
						help_indexqry();
					case 1:
						version();
				}
				exit(-1);
			case 'f':
				id_from = optarg;
				break;
			case 't':
				id_to = optarg;
				break;
			case 'o':
				output = optarg;
				break;
			case 's':
				char *tail;
				max_mem = strtol(optarg, &tail, 10);
				if (*tail == 'K' || *tail == 'k') 
					max_mem *= 1024;
				else if (*tail == 'M' || *tail == 'm') 
					max_mem *= 1048576;
				else if (*tail == 'G' || *tail == 'g') 
					max_mem *= 1073741824;
				else if (*tail && *tail != 'B' && *tail != 'b') 
					help_indexref();
				break;
			case 'u':
				mis_thr = str2long(optarg, 0, 200);
				break;
			case 'b':
				bisulfite = true;
				break;
			default:
				exit(1);
		}
	}
	if (optind+1 != argc)
		utl_error("main", 8,
			"pass indexqry: missing mandatory operand 'fasta file name'\npass indexqry: Try 'pass indexqry --help' for more information.\n");
	if (!output)
		utl_error("main", 9,
			"pass indexqry: missing mandatory operand '--output'\npass indexqry: Try 'pass indexqry --help' for more information.\n");
	FILE *fout = fopen(output, "w");
	if (fout == NULL) utl_error("main", 10, "pass indexqry: Cannot create file '%s'\n", output);
	char *sMajor = strdup(PACKAGE_VERSION); 
	char *sPeriod = strrchr(sMajor, '.');
	if (!sPeriod)
		utl_error("main", 11,
			"pass indexqry: package version string is wrong, contact developer");
	*sPeriod = 0;
	unsigned char major_len = (unsigned char) strlen(sMajor);
	check_write(fwrite(&major_len, sizeof(unsigned char), 1, fout) == 1);
	check_write(fwrite(sMajor, major_len, 1, fout) == 1);
	free(sMajor);
	check_write(fwrite(&bisulfite, sizeof(bool), 1, fout) == 1);
	check_write(fputc('Q', fout) != EOF);
	check_write(fwrite(&mis_thr, sizeof(unsigned char), 1, fout) == 1);
	fasta_reader *fa_reader = new fasta_reader(argv[optind], false, id_from, id_to, fout);
	if (max_mem > fa_reader->get_size()) max_mem -= fa_reader->get_size();
	if (max_mem < MIN_SORTSIZE)max_mem = MIN_SORTSIZE;
	char* tmpfile = (char*)malloc(strlen(output) + 9);
	check_alloc(tmpfile);
	sprintf(tmpfile, "%s.tmpfile", output);

	char *seq = fa_reader->get_seq_buffer();
	bool appended = false;
	for (int mis_idx=0; mis_idx<=mis_thr; mis_idx++) {
		sorter* srtr = new sorter(seq, fout, tmpfile, max_mem, bisulfite, 131072);
		uint64_t head = 0, seed_max_len = 0, cnt_ignore = 0;
		unsigned int seq_idx = 0;
		while (seq[head] != -1) {
			uint64_t s_len = strlen(seq+head);
			uint64_t unit_len = s_len / (mis_idx + 1);
			if (unit_len >= MIN_SHORTSEQ_LEN) {
				if (unit_len > seed_max_len) seed_max_len = unit_len;
				for (unsigned char i=0; i<mis_idx; i++) {
					uint64_t j = 0;
					for (; j<unit_len; j++)
						if (seq[head+j] == 'N') break;
					if (j == unit_len) {
						srtr->append(sequence(head, unit_len, seq_idx));
						appended = true;
					}
					head += unit_len;
				}
				uint64_t tail = head;
				while (seq[tail] && seq[tail] != 'N')
					tail++;
				if (!seq[tail]) {
					if (tail - head > seed_max_len) seed_max_len = tail - head;
					srtr->append(sequence(head, tail - head, seq_idx));
					appended = true;
				} else {
					tail++; 
					while (seq[tail]) tail++;
				}
				head = tail + 1;
			} else {
				head += s_len + 1;
				cnt_ignore++;
			}
			seq_idx++;
		}
		check_write(fwrite(&seed_max_len, sizeof(uint64_t), 1, fout) == 1);
		delete srtr;
		if (cnt_ignore)
			fprintf(stderr,
				"Warning: %ld sequences are not indexed at %d-mismatch because they are too short\n",
				cnt_ignore, mis_idx);
	}
	fclose(fout);
	free(tmpfile);
	delete fa_reader;
	if (!appended) {
		unlink(output);
		utl_error("main", 12, "Query fasta file '%s' has no sequence.\n", output);
	}
}
void pass_align(int argc, char *argv[]) {
	unsigned char gap = 0, mis_thr = UCHAR_MAX;
	int limit = 1, mis_from = 0;
	bool print_seq = false, print_all = false;
	int quality_score_base = -1;
	while (1) {
		int option_index = 0;
		static struct option l_options[] = {
			{"help", 0, 0, 0},
			{"version", 0, 0, 0},
			{"gap-of-indel", 1, 0, 'g'},
			{"max-num-of-match", 1, 0, 'n'},
			{"to-mismatch", 1, 0, 't'},
			{"from-mismatch", 1, 0, 'f'},
			{"quality-score-base", 1, 0, 'q'},
  			{"sequence", 0, 0,'s'},
			{"print-all", 0, 0, 'p'},
			{0, 0, 0, 0}
		};
		int opt = getopt_long(argc, argv, "g:n:t:f:q:sp", l_options, &option_index);
		if (opt == -1) break;
		switch(opt) {
			case 0:
				switch (option_index) {
					case 0:
						help_align();
					case 1:
						version();
				}
				exit(-1);
			case 'g':
				gap = str2long (optarg, 0, 200);
				break;
			case 'n':
				if (!strcmp(optarg, "unlimited"))
					limit = -1;
				else
					limit = str2long(optarg, 0, 254);
				break;
			case 't':
				mis_thr = str2long(optarg, 0, 200);
				break;
			case 'f':
				mis_from = str2long(optarg, 0, 200);
				break;
			case 'q':
				if (!strcmp(optarg, "none"))
					quality_score_base = -1;
				else if (!strcmp(optarg, "solexa"))
					quality_score_base = 64;
				else if (!strcmp(optarg, "normal"))
					quality_score_base = 33;
				else
					quality_score_base = str2long(optarg, 0, 255);
				break;
			case 's':
				print_seq = true;
				break;
			case 'p':
				print_all = true;
				break;
			default:
				exit(1);
		}
	}
	if (optind+2 != argc)
		utl_error("main", 13,
			"pass align %d, %d: missing mandatory index files\npass align: Try 'pass align --help' for more information.\n",
			optind, argc);
	if (gap && quality_score_base != -1)
		utl_error("main", 14,
			"if --gap is used, --quality-score-base cannot be a numeric value.\n");
	if (mis_from > mis_thr)
		utl_error("main", 14,
			"--from-mismatch should be between 0 and --max-mismatch\n");
	fasta_reader *fa_ref = NULL, *fa_qry = NULL;
	seq_reader *rd_ref = NULL, *rd_qry = NULL;
	uint64_t max_len;
	bool bisulfite;
	for (; optind<argc; optind++) {
		FILE *fin = fopen(argv[optind], "r");
		if (fin == NULL) utl_error("main", 15, "pass align: Cannot open file '%s'\n", argv[optind]);
		unsigned char major_len;
		check_read(fread(&major_len, sizeof(unsigned char), 1, fin) == 1);
		char *major_str = (char*)malloc(major_len+1);
		check_read(fread(major_str, major_len, 1, fin) == 1);
		major_str[major_len] = 0;
		if (strncmp(major_str, PACKAGE_VERSION, strlen(major_str)))
			utl_error("main", 16,
				"This index '%s' was built with version %s.?, but the program is version %s\n",
				argv[optind], major_str, PACKAGE_VERSION);
		free(major_str);
		if (optind != argc - 1)
			check_read(fread(&bisulfite, sizeof(bool), 1, fin) == 1);
		else {
			bool ano_bisulfite;
			check_read(fread(&ano_bisulfite, sizeof(bool), 1, fin) == 1);
			if (ano_bisulfite != bisulfite)
				utl_error("main", 17, "Files are indexed with different --bisulfite-conversion argument\n");
		}
		char c_type;
		check_read(fread(&c_type, sizeof(char), 1, fin) == 1);
		if (c_type == 'R') {
			check_read(fread(&max_len, sizeof(uint64_t), 1, fin) == 1);
			if (fa_ref) utl_error("main", 18, "Both files are reference pass file\n");
			fa_ref = new fasta_reader(true, fin, 0, mis_thr, -1, false, false);
			fasta_reader::_G_fa_ref = fa_ref;
			rd_ref = new seq_reader(fa_ref, fin, argv[optind]);
		} else if (c_type == 'Q') {
			unsigned char qry_mis_thr;
			check_read(fread(&qry_mis_thr, sizeof(unsigned char), 1, fin) == 1);
			if (fa_qry) utl_error("main", 19, "Both files are query pass file\n");
			if (mis_thr == UCHAR_MAX)
				mis_thr = qry_mis_thr;
			else if (mis_thr > qry_mis_thr)
				utl_error("main", 20,
					"Query index file is built with --up-to-mismatch=%d, --mismatch in align cannot be bigger that that.\n",
					qry_mis_thr);
			fa_qry = new fasta_reader(false, fin, limit, mis_thr, quality_score_base, print_seq, print_all);
			rd_qry = new seq_reader(fa_qry, fin, argv[optind]);
		} else
			utl_error("main", 21, "file '%s' is not a PASS index file\n", argv[optind]);
	}
	rd_qry->jump_to(mis_from);
	for (unsigned char mis_idx=mis_from; mis_idx<=mis_thr; mis_idx++) {
		rd_ref->init_ref();
		uint64_t qry_max_len = rd_qry->get_max_seed_len(max_len);
		seq_reader::align(rd_qry, rd_ref, mis_idx, qry_max_len, bisulfite, gap);
		fa_qry->print_match();
	}
	fa_qry->print_nomatch();
//	delete rd_ref;
//	delete rd_qry;
}
int main(int argc, char *argv[]) {
	if (argc < 2) 
		help_main();
	else if (argc == 2) {
		if (strcmp(argv[1], "--version") == 0) version();
		help_main();
	} else if (strcmp(argv[1], "indexref") == 0)
		pass_indexref(--argc, ++argv);
	else if (strcmp(argv[1], "indexqry") == 0)
		pass_indexqry(--argc, ++argv);
	else if (strcmp(argv[1], "align") == 0)
		pass_align(--argc, ++argv);
	else 
		help_main();
	fflush(stdout);
	fputs("Done\n", stderr);
	return 0;
}
